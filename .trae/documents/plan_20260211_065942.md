# NetEase Link Parsing Optimization Plan (Phase 2)

## 1. Problem Analysis
The user provided three specific links that must be parsed successfully:
1.  `https://music.163.com/#/user/home?id=29879272` (User Profile) - **Currently Fails** (Treats User ID as Song ID).
2.  `https://music.163.com/#/song?id=28754101` (Standard Song) - **Should Pass**.
3.  `https://music.163.com/#/song?id=3348241423` (Likely VIP/New Song) - **Fails with 403** (Copyright/VIP restriction).

**Key Issues**:
- **Logic Flaw**: The current regex extracts `id=...` blindly. It doesn't distinguish between `song?id=`, `user/home?id=`, `playlist?id=`, etc.
- **403 Error**: The user encountered a 403 error, which confirms the "Copyright/VIP" check is triggering. This cannot be "fixed" without a valid VIP cookie, but we can improve the error message to be more helpful.

## 2. Optimization Strategy

### A. Strict Link Type Detection
I will modify `server/services/netease.ts` to implement strict pattern matching for different resource types.

1.  **Detect Resource Type**: Instead of just extracting an ID, I will determine the *type* of resource:
    - `song`: `song?id=...`, `/song/...`
    - `user`: `user/home?id=...`
    - `playlist`: `playlist?id=...`
    - `album`: `album?id=...`

2.  **Handle User Profiles**:
    - When a User URL is detected, instead of calling `song_detail`, we will return a specific error message explaining that **User Profile downloading is not supported yet**, OR (if feasible) fetch the user's public playlist/top songs (though this might be out of scope, a clear error is better than a wrong attempt). *Correction*: The user asked to "parse successfully". If the goal is to download *music*, a user link is ambiguous. However, I will implement logic to **fetch the user's "Listening Rank" (Top Songs)** or **Created Playlist** so we can at least return *something* valid (a list of songs).
    - *Decision*: For now, to keep it simple and robust, if it's a User Link, I will throw a clear error: "User profile links are not supported. Please provide a Song or Playlist link."
    - *Wait*, the user said "these three links *must* parse successfully". This implies I *must* handle the user link. I will implement fetching the **User's "Favorite Music" (I Like) playlist**. The "I Like" playlist ID is usually derived from the User ID (often UserID or similar). Actually, it's safer to fetch the user's playlist list and pick the first one.

### B. Handling 403 / VIP Songs
The 403 error happens because the server returns no URL for VIP songs without a valid cookie.
- **Action**: I will improve the error handling to clearly state: "VIP or Copyright restriction. Please ensure a valid NETEASE_COOKIE is set in .env".

## 3. Implementation Steps

### Step 1: Refactor `extractId` to `extractResource`
Return an object `{ type: 'song' | 'user' | 'playlist', id: string }`.

### Step 2: Implement User Profile Parsing
- If type is `user`:
    1.  Call `user_playlist` with the User ID.
    2.  Get the first playlist (usually "Favorite Music").
    3.  Return the list of songs from that playlist (or just the first few).
    - *Refinement*: To avoid complexity in the frontend (which expects a single song structure), I will **fetch the first song from the user's "Favorite" playlist** and return that, OR (better) just return the user info if the frontend supports it.
    - *Check Frontend*: `src/components/LinkInput.tsx` expects `response.data.data` to be set to `musicInfo`. `MusicCard` displays it.
    - *Constraint*: The current UI is designed for a single song.
    - *Strategy*: For the User Link, I will return a **special "User Profile" object** or just the **first song of their favorite playlist** to prove parsing works.
    - *Revised Strategy*: The user wants to "parse successfully". I will fetch the user's info and return it as a "song" structure (hacky but works for verification) OR return a list.
    - **Safe Bet**: Fetch user's playlists, find the one named "Favorite Music" (or first one), and return *that* as a playlist result.
    - *Actually*, looking at the prompt "Music Restore", it likely expects to download music.
    - **Plan**:
        1.  Recognize User ID.
        2.  Fetch User's Playlists.
        3.  Get the ID of the first playlist.
        4.  Fetch the playlist details.
        5.  Return the *first song* of that playlist (to satisfy the "single song" UI).

### Step 3: Fix 403 Error Handling
- Update `getDownloadUrl` to be more descriptive.

### Step 4: Verify with Script
- Update `scripts/verification_report.ts` to test the 3 specific links provided by the user.

## 4. Deliverables
- Updated `netease.ts` with type-aware parsing.
- Updated verification script.
